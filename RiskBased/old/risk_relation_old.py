import os
from openai import OpenAI
from dotenv import load_dotenv

load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

AGENT2_VARIANTS = [
    {"id": "v1", "model": "gpt-4", "temperature": 0.3, "top_p": 1.0},
    {"id": "v2", "model": "gpt-4", "temperature": 0.7, "top_p": 0.9},
    {"id": "v3", "model": "gpt-4", "temperature": 1.0, "top_p": 0.85},
]
AGENT1_CONFIG = {"model": "gpt-4", "temperature": 0.0, "top_p": 1.0}

INPUT_FILE_ALL = "../all_tests.txt"
INPUT_FILE_REG = "../regressiontext.txt"
BASE_OUTPUT_DIR = "final_test_orders"
TOTAL_TOKENS_USED = 0

def create_run_directory(base_dir="final_test_orders"):
    os.makedirs(base_dir, exist_ok=True)
    existing = [d for d in os.listdir(base_dir) if d.startswith("run_") and os.path.isdir(os.path.join(base_dir, d))]
    nums = [int(d.split("_")[1]) for d in existing if d.split("_")[1].isdigit()]
    run_number = max(nums) + 1 if nums else 1
    run_dir = os.path.join(base_dir, f"run_{run_number:02d}")
    os.makedirs(run_dir, exist_ok=True)
    return run_dir

def load_tests():
    with open(INPUT_FILE_ALL, "r", encoding="utf-8") as f:
        all_lines = [line.strip() for line in f if " - " in line]
    with open(INPUT_FILE_REG, "r", encoding="utf-8") as f:
        regression_lines = [line.strip() for line in f if line.strip()]
    return all_lines, regression_lines

def call_openai(prompt, config):
    messages = [{"role": "user", "content": prompt}]
    response = client.chat.completions.create(
        model=config["model"],
        messages=messages,
        temperature=config.get("temperature", 0.7),
        top_p=config.get("top_p", 0.9)
    )
    return response.choices[0].message.content.strip()

def generate_prompts(all_tests, regression_tests, base_risk_order):
    test_text = "\n".join(all_tests)
    reg_text = "\n".join(regression_tests)
    shared_intro = (
        f"All unit tests:\n{test_text}\n\n"
        f"Regression test cases:\n{reg_text}\n\n"
        f"Given risk order: {base_risk_order}\n\n"
        f"You must only use module names that exist in the provided unit test list.\n"
        f"Do NOT invent or include module names that do not appear.\n"
        f"Respond in format: A > B > C > D\n\n"
        f"After this, list the related modules after each base module in the following format: A: C, B: D"
    )
    input_prompt = shared_intro + (
        "Expand the risk order by inserting related modules immediately after their base modules.\n"
        "Determine relationships from how unit and regression tests group them.\n"
        "Example: input 'A > C' must become 'A > C > B > D' if B relates to A and D to C.\n"
        "Make sure that given cases like A and C in the example are at the beginning in your ordering \n"
        "And if there are any other services that are not related to A or C at all, they should appear at the end of the list\n"
    )
    relation_prompt = shared_intro + (
        "Expand the risk order by appending modules that commonly appear with risky ones. You need the add related modules after inputs\n"
        "Use module co-occurrence from unit and regression tests.\n"
        "Example: input 'A > C' must become 'A > B > C > D' if B relates to A and D to C. A and C have to be first. Also  B need to be before D since A > C and B is related with A.\n"
        "And if there are any other services that are not related to A or C at all, they should appear at the end of the list\n"
    )
    return input_prompt, relation_prompt

def evaluate_risks(risk_path, log_path):
    with open(risk_path, "r", encoding="utf-8") as f:
        risks = [line.strip() for line in f if ":" in line]
    prompt = (
        "You are a validation assistant.\n"
        "Below are risk orders generated by another AI.\n"
        "Check if they match the intended structure:\n"
        "- input_first: related modules must follow directly.\n Example: input 'A > C' must become 'A > C > B > D' if B relates to A and D to C."
        "- relation_first: related modules appended but logical.\n\n Example: input 'A > C' must become 'A > B > C > D' if B relates to A and D to C. A and C have to be first. Also  B need to be before D since A > C and B is related with A."
        "Validate each. If all good, respond ONLY: OK\n"
        "If not, explain briefly.\n\n" + "\n".join(risks)
    )
    print("risks:\n", risks)
    result = call_openai(prompt, AGENT1_CONFIG)
    print("validation agent result\n", result)
    with open(log_path, "a", encoding="utf-8") as log:
        log.write("[Agent1 Evaluation]\n")
        log.write(result + "\n")
    return result.strip() == "OK"

def run_agent2_and_save_orders(prompts, run_dir, process_log_path):
    all_tests, _ = load_tests()
    risk_path = os.path.join(run_dir, "all_risk_orders.txt")
    with open(risk_path, "w", encoding="utf-8") as f, \
        open(process_log_path, "a", encoding="utf-8") as process_log:
        print("run_agent2_and_save_orders")
        for label, prompt in prompts:
            for cfg in AGENT2_VARIANTS:
                tag = f"{label}_temp{cfg['temperature']}_top{cfg['top_p']}"
                result = call_openai(prompt, cfg)
                print("prompt:", prompt)
                print("result:", result)
                f.write(f"{tag}: {result}\n")
                process_log.write(f"[Agent2] Generated risk order {tag}: {result}\n")

def run_agent3_if_approved(run_dir, all_tests):
    test_names = [line.split(" - ")[0].strip() for line in all_tests]
    with open(os.path.join(run_dir, "all_risk_orders.txt"), "r", encoding="utf-8") as f:
        for line in f:
            if ":" not in line: continue
            label, risk_order = line.split(":", 1)
            test_prompt = (
                f"You are a test optimization assistant.\n\n"
                f"Now I will give you regression and unit test cases. Your job is to reorder the test names to maximize early cumulative risk mitigation based on the following module risk order:\n"
                f"{risk_order.strip()}\n\n"
                f"Each test is in the format:\nClassName#testMethod - short description\n\n"
                f"⚙️ Input Parameters:\n"
                f"- Total number of tests: {len(test_names)}\n"
                f"- You must return exactly {len(test_names)} test names.\n"
                f"- All returned test names must come from the provided list.\n"
                f"- Do NOT add, remove, rename, or duplicate any tests.\n\n"
                f"⚠️ Important Instruction:\n"
                f"You must reorder exactly the test names I provide. Do not add anything. Do not change anything.\n"
                f"Just return the same test names in a better order to mitigate higher-risk modules earlier.\n\n"
                f"✅ Output format:\n"
                f"{chr(10).join(test_names)}"
            )
            result = call_openai(test_prompt, AGENT1_CONFIG)
            with open(os.path.join(run_dir, f"tests_{label.strip()}.txt"), "w", encoding="utf-8") as out:
                out.write(result.strip())

def main():
    global TOTAL_TOKENS_USED
    all_tests, regression_tests = load_tests()

    valid_modules = {
    line.split("#")[0].replace("Test", "").strip()
    for line in all_tests
}


    while True:
        base_risk_order = input("Enter base risk order (e.g., A > B > C) or type 'all' to list available modules: ").strip()
        if base_risk_order.lower() == "all":
            print("\n✅ Available modules:")
            print(", ".join(sorted(valid_modules)))
            print()
            continue
        input_modules = [x.strip() for x in base_risk_order.split(">") if x.strip()]
        missing = [mod for mod in input_modules if mod not in valid_modules]
        if missing:
            print("❌ Invalid input. The following modules are not found in all_tests.txt:")
            print(", ".join(missing))
            print("Please enter a valid risk order using only existing modules.\n")
            continue
        else:
            break

    run_dir = create_run_directory(BASE_OUTPUT_DIR)
    process_log = os.path.join(run_dir, "process.txt")

    with open(process_log, "w", encoding="utf-8") as f:
        f.write("=== PROCESS LOG ===\n")

    while True:
        input_prompt, relation_prompt = generate_prompts(all_tests, regression_tests, base_risk_order)
        prompts = [("input_first", input_prompt), ("relation_first", relation_prompt)]

        with open(process_log, "a", encoding="utf-8") as log:
            log.write("Generating risk orders with Agent2...\n")
        run_agent2_and_save_orders(prompts, run_dir, process_log)

        with open(process_log, "a", encoding="utf-8") as log:
            log.write("Evaluating risk orders with Agent1...\n")
        ok = evaluate_risks(os.path.join(run_dir, "all_risk_orders.txt"), process_log)

        if ok:
            with open(process_log, "a", encoding="utf-8") as log:
                log.write("Agent1 approved risk orders. Proceeding to Agent3.\n")
            run_agent3_if_approved(run_dir, all_tests)
            break
        else:
            with open(process_log, "a", encoding="utf-8") as log:
                log.write("Agent1 rejected risk orders. Looping back with updated prompts.\n")

if __name__ == "__main__":
    main()
